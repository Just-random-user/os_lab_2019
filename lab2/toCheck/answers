Как менять занчения переменных внутри функций в Си.
{
    int a, b;
    b = 1234;
    a = b;
    //Что значит внутри функции? main - тоже функция
    //Имеется в виду изменять значение внешней переменной?

    void change(int* variable) {
        *variable = 524;
        return;
    }

    int main(void) {
        int a;
        change(&a);
    }
}
Выделение и освобождение памяти в куче Си.
{
    int* arr = (int*)malloc(<size in bytes>); //allocating memory
    free(arr); //putting memory back to the heap
    int* arr = (int*)calloc(<number of elements>, <size of one>);//allocating memory, filling it with 0's
    int* arr = (int*)realloc(arr, <new size>);//reallocating memory
}
В чем разница между стеком и кучей (прямо в задании не потребуется, но я спрошу).
{
    Размер стека определяется при запуске программы и не изменяется до её окончания; действует по принципу LIFO;
    высокая скорость работы за счёт статичности и принципа работы.

    Куча - общая область оперативной памяти; выделяется и освобождается по запросу программы в любое время; низкая скорость
    вследствии необходимости процедурного выделения и освобождения памяти, что также требует ресурсов процессора;
    доступ к информации получается сложнее, чем в стеке. 
}
Использование аргументов командной строки
{
    записи, идущие после названия команды принимаются в качестве аргументов
    ./programme mtr -8
    выполнит программу "programme" с аргументами "mtr" и "-8"
}
Основы работы компилятора: препроцессор, компилятор, линковщик. Их роли и порядок работы.
{
    Препроцессор раотает с дериктивами #include #define #if и так далее, а также удаляет комментарии
    Компилятор переводит код с ЯП в машинный код через язык ассемблера
    Линковщик связывает все объектные файлы и статические библиотеки в единый исполняемый файл
}
Что такое статическая и динамическая линковка. В чем разница?
{
    Статическая линковка происходит при компиляции и присоединяет всю линкуемую библиотеку; высокая скорость,
    большой конечный размер, необходимость перекомпиляции при изменении в такой библиотеке или исходном файле

    При динамической линковке функция из библиотеки предоставляется по запросу при исполнении программы, низкая скорость,
    небольшой конечный размер, не теобходимости перекомпиляции всего проекта при изменениях в отдельных файлах
}
Опции компилятора: -I, -L, -l, -shared, -o, -с, -fPIC
{
    -o <файл> - загрузить результат в определённй файл
    -c - ассемблирование без компиляции
    -shared - создание динамической библиотеки
    -fPIC - ключ, определяющий, что все процессы, использующие данную библиотеку, будут вместе использовать одну её копию,
    а не загружать её снова под себя
    -l<lib> определяет подключаемую библиотеку (liblib.a)
    -L<dir> добавить директорию dir в список поиска библиотек
    -I<dir> добавить каталог dir в список поиска каталогов, содержащих include- файлы 
}
Утилита ar
{
    Стандартная архивирующая утилита linux, используемая, преимущественно, для создания статических библиотек. 
}
Переменная окружения LD_LIBRARY_PATH
{
    Переменная, в которую через ":" записаны адреса стандартных библиотек, которые будут использоваться дополнительно при всех
    компиляциях как аргументы -L
}